<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MANOS FIGHT - Protótipo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background-color: #1a202c; color: #e2e8f0; margin: 0; padding: 20px; box-sizing: border-box; overflow-x: hidden; -webkit-tap-highlight-color: transparent; }
        .screen { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 800px; padding: 20px; background-color: #2d3748; border-radius: 0.5rem; margin-bottom: 20px; text-align: center; }
        .screen.active { display: flex; }
        .screen h2 { color: #63b3ed; margin-bottom: 20px; }
        .screen h3 { color: #a0aec0; margin-bottom: 10px; }
        .options-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; width: 100%; margin-bottom: 20px; }
        .button, .character-option, .difficulty-option { background-color: #4a5568; color: #e2e8f0; padding: 12px 20px; border: 2px solid transparent; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s ease-in-out; font-weight: bold; text-align: center; }
        .button:hover, .character-option:hover, .difficulty-option:hover { background-color: #718096; }
        .character-option.selected, .difficulty-option.selected { border-color: #f6e05e; transform: scale(1.05); background-color: #5a667a; }
        .character-option.unavailable { opacity: 0.5; cursor: not-allowed; background-color: #4a5568 !important; }
        .character-option.unavailable:hover { transform: scale(1); }
        #startGameButton { background-color: #48bb78; } #startGameButton:hover { background-color: #38a169; }
        #startGameButton:disabled { background-color: #718096; cursor: not-allowed; }

        #gameContainer { display: none; flex-direction: column; align-items: center; }
        #gameCanvas { 
            border: 2px solid #4a5568; 
            background-color: #3c996000; 
            border-radius: 0.5rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            position:relative;
            background-image: url("img/Imagem do WhatsApp de 2025-05-31 à(s) 02.37.40_bab8b7c8.jpg"); /* Placeholder */
            background-size: contain; 
            background-position: center center; 
            background-repeat: no-repeat; 
        }
        .controls-container { display: flex; flex-wrap: wrap; justify-content: space-around; width: 100%; max-width: 800px; margin-top: 20px; padding: 15px; background-color: #2d3748; border-radius: 0.5rem; }
        .player-controls { background-color: #4a5568; padding: 15px; border-radius: 0.5rem; margin: 10px; min-width: 250px; }
        .player-controls h3 { margin-top: 0; color: #a0aec0; border-bottom: 1px solid #718096; padding-bottom: 5px; }
        .player-controls ul { list-style: none; padding: 0; } .player-controls li { margin-bottom: 5px; font-size: 0.9em; }
        
        #uiOverlay { width: 100%; max-width: 800px; margin-bottom: 5px; } 
        #scoreDisplay { display: flex; justify-content: space-around; width: 100%; color: #f6e05e; font-size: 1.2em; font-weight: bold; margin-bottom: 5px;}
        .player-score span { margin: 0 5px; }
        #healthBars { display: flex; justify-content: space-between; width: 100%; }
        .health-bar-container, .special-bar-container { width: 45%; background-color: #4a5568; border-radius: 0.25rem; padding: 5px; box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.06); margin-bottom:5px; }
        .health-bar, .special-bar { height: 25px; border-radius: 0.25rem; transition: width 0.3s ease-in-out; text-align: center; line-height: 25px; font-weight: bold; color: white; font-size: 0.8rem; }
        .special-bar { background-color: #d69e2e; height:15px; line-height:15px; font-size:0.7rem;}
        .special-bar.ready { background-color: #f6e05e; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        #roundStartMessage, #pauseMessage {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.75); color: #f6e05e; padding: 20px 40px;
            border-radius: 10px; font-size: 2.5em; text-align: center;
            display: none; z-index:150; border: 2px solid #f6e05e;
            background-position:center;
            background-repeat: no-repeat;
            background-size: auto;
        }
        #pauseMessage { top: 50%; font-size: 3em; }

        #messageArea { margin-top: 15px; font-size: 1.5em; font-weight: bold; color: #f6e05e; height: 30px; text-align: center; }
        h1 { color: #63b3ed; margin-bottom: 20px; text-align:center; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal-content { background-color: #2d3748; margin: auto; padding: 30px; border: 1px solid #4a5568; width: 80%; max-width: 500px; border-radius: 0.5rem; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
        .modal-content h2 { margin-top: 0; color: #63b3ed; }
        .modal-content button { background-color: #48bb78; color: white; padding: 10px 20px; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 1em; margin-top: 20px; transition: background-color 0.2s; }
        .modal-content button:hover { background-color: #38a169; }

        /* Touch Controls Styling */
        #touchControlsContainer { display: none; position: fixed; bottom: 0; left: 0; width: 100%; z-index: 200; user-select: none; -webkit-user-select: none; padding-bottom: env(safe-area-inset-bottom, 10px); box-sizing: border-box;}
        .touch-button { background-color: rgba(100,100,100,0.5); color: white; border: 1px solid rgba(200,200,200,0.7); display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.5em; }
        .touch-button:active { background-color: rgba(150,150,150,0.7); }

        #touchLeftControls { position: absolute; left: 5%; bottom: 20px; display: flex; flex-direction: column; align-items: center; }
        #touchLeftControls .dpad-row { display: flex; }
        #touchUpBtn { width: 60px; height: 60px; border-radius: 50% 50% 0 0; margin-bottom: 2px; }
        #touchLeftBtn { width: 60px; height: 60px; border-radius: 50% 0 0 50%; margin-right: 2px; }
        #touchRightBtn { width: 60px; height: 60px; border-radius: 0 50% 50% 0; }
        #touchDownBtn { width: 60px; height: 60px; border-radius: 0 0 50% 50%; margin-top: 2px; }
        #dpadCenter { width: 60px; height: 60px; background-color: transparent; position: relative; margin: -60px 0 0 0; }


        #touchRightControls { position: absolute; right: 5%; bottom: 20px; display: flex; flex-direction: column; align-items: center; }
        #touchSpecialBtn { width: 60px; height: 60px; border-radius: 50%; background-color: rgba(200,150,50,0.6); margin-bottom: 15px; font-size: 1.2em; }
        .action-buttons-row { display:flex; }
        #touchKickBtn { width: 70px; height: 70px; border-radius: 50%; background-color: rgba(100,100,200,0.6); margin-right: 15px; }
        #touchPunchBtn { width: 70px; height: 70px; border-radius: 50%; background-color: rgba(200,100,100,0.6); }

        #touchPauseBtn { position: absolute; top: 15px; right: 15px; width: 50px; height: 40px; border-radius: 8px; font-size: 1.2em;}

    </style>
</head>
<body>
    <h1>MANOS FIGHT</h1>

    <div id="modeSelectScreen" class="screen active">
        <h2>Escolha o Modo de Jogo</h2>
        <div class="options-grid">
             <button class="button" id="pvcpuButton">Jogador vs CPU</button> 
        </div>
    </div>

    <div id="p1CharSelectScreen" class="screen">
        <h2>Jogador 1: Escolha seu Lutador</h2>
        <div class="options-grid" id="p1CharacterOptions"></div>
        <p>Toque no personagem para selecionar.</p>
    </div>
    
    <div id="cpuCharSelectScreen" class="screen">
        <h2>Escolha o Lutador da CPU</h2>
        <div class="options-grid" id="cpuCharacterOptions"></div>
        <p>Toque no personagem para selecionar.</p>
    </div>

    <div id="difficultySelectScreen" class="screen">
        <h2>Escolha a Dificuldade da CPU</h2>
        <div class="options-grid">
            <button class="difficulty-option" data-difficulty="easy">Só a garapa</button>
            <button class="difficulty-option" data-difficulty="medium">Marromeno</button>
            <button class="difficulty-option" data-difficulty="hard">Lucura baitola</button>
        </div>
    </div>

    <div id="gameContainer">
        <div id="uiOverlay">
            <div id="scoreDisplay">
                <div class="player-score" id="player1Score">J1: <span>0</span></div>
                <div id="currentRoundDisplay">Round: 1</div>
                <div class="player-score" id="player2Score">CPU: <span>0</span></div>
            </div>
            <div id="healthBars">
                <div class="health-bar-container"><div id="player1HealthBar" class="health-bar"><span id="player1HealthBarName">P1</span>: 100%</div></div>
                <div class="health-bar-container"><div id="player2HealthBar" class="health-bar"><span id="player2HealthBarName">CPU</span>: 100%</div></div>
            </div>
            <div id="specialBars" style="display: flex; justify-content: space-between; width: 100%;">
                 <div class="special-bar-container"><div id="player1SpecialBar" class="special-bar">P1 Especial: 0%</div></div>
                 <div class="special-bar-container"><div id="player2SpecialBar" class="special-bar">CPU Especial: 0%</div></div>
            </div>
        </div>
        <div style="position:relative;"> 
            <canvas id="gameCanvas"></canvas> 
            <div id="roundStartMessage">Round 1</div>
            <div id="pauseMessage">PAUSADO</div>
        </div>
        <div id="messageArea"></div>
        <div class="controls-container"> 
            <div class="player-controls" id="p1ControlsDisplay">
               
            </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal"> <div class="modal-content"><h2 id="gameOverMessage"></h2><button id="restartButton">Voltar ao Menu</button></div>
    </div>

    <div id="touchControlsContainer">
        <div id="touchLeftControls">
            <button id="touchUpBtn" class="touch-button">▲</button>
            <div class="dpad-row">
                <button id="touchLeftBtn" class="touch-button">◄</button>
                <div id="dpadCenter"></div>
                <button id="touchRightBtn" class="touch-button">►</button>
            </div>
            <button id="touchDownBtn" class="touch-button">▼</button>
        </div>

        <div id="touchRightControls">
            <button id="touchSpecialBtn" class="touch-button">ESP</button>
            <div class="action-buttons-row">
                <button id="touchKickBtn" class="touch-button">K</button>
                <button id="touchPunchBtn" class="touch-button">P</button>
            </div>
        </div>
        <button id="touchPauseBtn" class="touch-button">❚❚</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const BASE_CANVAS_WIDTH = 800; 
        const BASE_CANVAS_HEIGHT = 400; 
        
        let canvasWidth, canvasHeight;
        let PLAYER_WIDTH_SCALED, PLAYER_HEIGHT_SCALED, PLAYER_SPEED_SCALED, JUMP_FORCE_SCALED, ATTACK_RANGE_SCALED; 

        function setupCanvasDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const targetAspectRatio = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT; 

            let newCanvasWidth = Math.min(viewportWidth * 0.95, BASE_CANVAS_WIDTH); 
            let newCanvasHeight = newCanvasWidth / targetAspectRatio;

            if (newCanvasHeight > viewportHeight * 0.70) {
                newCanvasHeight = viewportHeight * 0.70;
                newCanvasWidth = newCanvasHeight * targetAspectRatio;
            }
            
            canvas.width = newCanvasWidth;
            canvas.height = newCanvasHeight;
            canvasWidth = newCanvasWidth; 
            canvasHeight = newCanvasHeight; 

            const scaleFactor = canvas.width / BASE_CANVAS_WIDTH;
            
            // *** TAMANHO DOS PERSONAGENS AJUSTADO AQUI ***
            // Valores originais: 100 e 150. Reduzidos em 25%
            const basePlayerWidth = 100; // Original 100
            const basePlayerHeight = 150.5; // Original 150 (150 * 0.75 = 112.5)

            PLAYER_WIDTH_SCALED = basePlayerWidth * scaleFactor; 
            PLAYER_HEIGHT_SCALED = basePlayerHeight * scaleFactor;
            // ---------------------------------------------

            PLAYER_SPEED_SCALED = 7 * scaleFactor; 
            JUMP_FORCE_SCALED = -15 * scaleFactor;
            ATTACK_RANGE_SCALED = 30 * scaleFactor; // Pode precisar de ajuste se os personagens menores tornarem o alcance estranho
        }
        
        const screens = { modeSelect: document.getElementById('modeSelectScreen'), p1CharSelect: document.getElementById('p1CharSelectScreen'), cpuCharSelect: document.getElementById('cpuCharSelectScreen'), difficultySelect: document.getElementById('difficultySelectScreen'),};
        const gameContainer = document.getElementById('gameContainer');
        const p1CharOptionsContainer = document.getElementById('p1CharacterOptions'); const cpuCharOptionsContainer = document.getElementById('cpuCharacterOptions');
        const messageArea = document.getElementById('messageArea');
        const player1HealthBarEl = document.getElementById('player1HealthBar'); const player1HealthBarNameEl = document.getElementById('player1HealthBarName');
        const player2HealthBarEl = document.getElementById('player2HealthBar'); const player2HealthBarNameEl = document.getElementById('player2HealthBarName');
        const player1SpecialBarEl = document.getElementById('player1SpecialBar'); const player2SpecialBarEl = document.getElementById('player2SpecialBar');
        const p1ControlsDisplayH3 = document.getElementById('p1ControlsDisplay').querySelector('h3'); 
        const p2ControlsDisplayDiv = document.getElementById('p2ControlsDisplay'); 
        const gameOverModal = document.getElementById('gameOverModal'); const gameOverMessage = document.getElementById('gameOverMessage'); const restartButton = document.getElementById('restartButton');
        const roundStartMessageEl = document.getElementById('roundStartMessage');
        const pauseMessageEl = document.getElementById('pauseMessage');
        const player1ScoreEl = document.getElementById('player1Score').querySelector('span');
        const player2ScoreEl = document.getElementById('player2Score').querySelector('span');
        const currentRoundDisplayEl = document.getElementById('currentRoundDisplay');

        const touchControlsContainer = document.getElementById('touchControlsContainer');
        const touchUpBtn = document.getElementById('touchUpBtn');
        const touchDownBtn = document.getElementById('touchDownBtn');
        const touchLeftBtn = document.getElementById('touchLeftBtn');
        const touchRightBtn = document.getElementById('touchRightBtn');
        const touchPunchBtn = document.getElementById('touchPunchBtn');
        const touchKickBtn = document.getElementById('touchKickBtn');
        const touchSpecialBtn = document.getElementById('touchSpecialBtn');
        const touchPauseBtn = document.getElementById('touchPauseBtn');


        const GRAVITY = 0.8; 
        const ATTACK_DURATION = 200, PUNCH_DAMAGE = 10, KICK_DAMAGE = 15, MAX_HEALTH = 200;
        const KNOCKDOWN_HIT_THRESHOLD = 5, KNOCKDOWN_JUMP_FORCE_MULTIPLIER = 0.7, KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER = 0.3;
        const GROUNDED_DURATION = 1500, SCREEN_SHAKE_INTENSITY = 8, SCREEN_SHAKE_DURATION_MS = 250;
        const AERIAL_ATTACK_PUSHBACK_FORCE = 8; const CROUCH_KNOCKDOWN_THRESHOLD = 2; 
        const COMBO_WINDOW_MS = 700; const POST_COMBO_COOLDOWN_MS = 1800;
        const SPECIAL_METER_MAX = 7; 
        const SPECIAL_ATTACK_DAMAGE_MULTIPLIER = 5; 
        const VINI_SPECIAL_NOTIFICATION_DURATION = 1500; const VINI_SPECIAL_HEARTS_DURATION = 1000; const VINI_SPECIAL_MESSAGE_DURATION = 3000;
        const VINI_SPECIAL_RAGE_TRANSFORM_DURATION = 500; const VINI_SPECIAL_CHARGE_DURATION = 700; const VINI_SPECIAL_RUSH_DURATION = 1200;
        const OPPONENT_SPECIAL_HIT_FALL_DURATION = 2000; 
        const MAX_ROUNDS = 3; 
        const ROUND_END_DELAY = 3000; 
        
        const MAGAL_SPECIAL_SETUP_BAR_DURATION = 800; 
        const MAGAL_SPECIAL_DRINK_DURATION_PER_BOTTLE = 1500; 
        const MAGAL_SPECIAL_THROW_INTERVAL = 300; 
        const MAGAL_SPECIAL_AFTER_THROW_INTERVAL = 500; 
        const MAGAL_SPECIAL_BOTTLE_SPEED = 10; 
        const MAGAL_SPECIAL_BOTTLE_DAMAGE = PUNCH_DAMAGE * 0.9; 
        const MAGAL_SPECIAL_BOTTLE_WIDTH = 10; const MAGAL_SPECIAL_BOTTLE_HEIGHT = 25;
        const MAGAL_SPECIAL_DISCO_DURATION = 2500; const MAGAL_SPECIAL_FINAL_MESSAGE_DURATION = 3000;
        const MAGAL_BAR_TABLE_WIDTH = 80; const MAGAL_BAR_TABLE_HEIGHT = 40; const MAGAL_BAR_SLIDE_SPEED = 7;
        
        const PEDRO_SPECIAL_INJECT_DURATION = 1800; 
        const PEDRO_SPECIAL_PUMP_DURATION = 2500; 
        const PEDRO_SPECIAL_RUSH_SPEED_MULTIPLIER = 3.0; 
        const PEDRO_SPECIAL_PUNCH_COUNT = 5;
        const PEDRO_SPECIAL_PUNCH_INTERVAL = 350; 
        const PEDRO_SPECIAL_FINAL_PUNCH_LAUNCH_MULTIPLIER = 1.8;

        let currentP1CharIndex = 0, currentCpuCharIndex = 0; 
        let selectedP1Char = null, selectedCpuChar = null; 
        let selectedDifficulty = null; let gameMode = 'pvcpu'; 
        let currentScreen = 'modeSelect';
        let matchOver = false; let players = [null, null]; const keys = {}; 
        let screenShakeActive = false, currentScreenShakeIntensity = 0, currentScreenShakeDuration = 0, lastTime = 0;
        let aiActionCooldown = 0; const AI_ACTION_COOLDOWN_BASE = 500; 
        let currentRound = 1;
        let player1RoundWins = 0; let player2RoundWins = 0;
        let isPaused = false;
        let roundOverState = false; 
        let roundOverTimer = 0;
        let projectiles = []; 
        
        const playerSprites = {};
        let imagesToLoadCount = 0;
        let imagesLoadedCount = 0;
        let allImagesProcessedCheck = false; 

        function checkAllImagesProcessed() {
            if (!allImagesProcessedCheck && imagesLoadedCount >= imagesToLoadCount) {
                allImagesProcessedCheck = true; 
                if (currentScreen === 'game' && !lastTime && !matchOver && !isPaused && !roundOverState) {
                    lastTime = 0; 
                    requestAnimationFrame(gameLoop); 
                }
            }
        }
        
        function loadImage(key, src) {
            imagesToLoadCount++;
            playerSprites[key] = new Image();
            playerSprites[key].crossOrigin = "Anonymous"; 
            playerSprites[key].src = src;
            playerSprites[key].onload = () => { imagesLoadedCount++; checkAllImagesProcessed(); };
            playerSprites[key].onerror = (e) => { console.error(`Erro ao carregar o sprite ${key} de ${src}. URL: ${playerSprites[key].src}. Detalhes do erro:`, e); imagesLoadedCount++; checkAllImagesProcessed(); };
        }
        
        loadImage('vini_idle', 'img/cassiano.png');
        loadImage('markin_idle', 'img/chipa.png');
        loadImage('magal_idle','img/magal.png');
        loadImage('pedro_idle','img/predo.png');
        loadImage('freitas_idle','https://placehold.co/100x150/d946ef/white?text=FREITAS');


        const availableCharacters = [ 
            { id: 'vini', name: "VINI", color: '#4299e1', spriteKey: 'vini_idle' }, 
            { id: 'magal', name: "MAGAL", color: '#f56565', spriteKey: 'magal_idle' }, 
            { id: 'pedro', name: "PEDRO", color: '#48bb78', spriteKey: 'pedro_idle' },
            { id: 'markin', name: "MARKIN", color: '#06b6d4', spriteKey: 'markin_idle' }, 
            { id: 'freitas', name: "FREITAS", color: '#d946ef', spriteKey: 'freitas_idle' }
        ];
        const combos = [ { sequence: ['punch', 'punch', 'punch'], name: "Soco Triplo" }, { sequence: ['punch', 'punch', 'punch', 'kick', 'kick'], name: "Combo Furioso" }, { sequence: ['kick', 'kick', 'kick'], name: "Chute Triplo" }, { sequence: ['kick', 'kick', 'kick', 'punch', 'punch'], name: "Combo Demolidor" }];
        
        function updateHealthBars() { players.forEach((p, index) => { if (!p) return; const barEl = index === 0 ? player1HealthBarEl : player2HealthBarEl; const nameSpan = index === 0 ? player1HealthBarNameEl : player2HealthBarNameEl; const percent = (p.health / p.maxHealth) * 100; barEl.style.width = `${Math.max(0, percent)}%`; nameSpan.textContent = `${p.name.toUpperCase()}`; if (barEl.childNodes.length > 1 && barEl.lastChild.nodeType === Node.TEXT_NODE) { barEl.removeChild(barEl.lastChild); } barEl.appendChild(document.createTextNode(`: ${Math.max(0, Math.round(percent))}%`)); barEl.style.backgroundColor = p.color; });}
        function updateSpecialBars() { players.forEach((p, index) => { if (!p) return; const barEl = index === 0 ? player1SpecialBarEl : player2SpecialBarEl; const percent = (p.specialMeter / SPECIAL_METER_MAX) * 100; barEl.style.width = `${Math.max(0, percent)}%`; barEl.textContent = `${p.name.substring(0,1)} Esp: ${Math.floor(percent)}%`; if (p.specialReady) barEl.classList.add('ready'); else barEl.classList.remove('ready'); });}
        function updateScoreDisplay() { player1ScoreEl.textContent = player1RoundWins; player2ScoreEl.textContent = player2RoundWins; currentRoundDisplayEl.textContent = `Round: ${currentRound}`;}
        
        function switchScreen(screenName) { 
            Object.values(screens).forEach(s => s.classList.remove('active')); 
            if (screens[screenName]) {
                screens[screenName].classList.add('active');
            } else if (screenName === 'game') {
                gameContainer.style.display = 'flex';
            } 
            
            if (screenName !== 'game') {
                gameContainer.style.display = 'none';
                touchControlsContainer.style.display = 'none';
            } else {
                touchControlsContainer.style.display = 'block';
            }
            currentScreen = screenName; 
        }
        
        function populateCharacterOptions(container, forPlayer, currentIndex) { 
            container.innerHTML = ''; 
            availableCharacters.forEach((char, index) => { 
                const opt = document.createElement('button'); 
                opt.classList.add('character-option'); 
                opt.textContent = char.name; 
                opt.style.color = char.color; 
                opt.style.borderColor = char.color; 
                opt.dataset.charIndex = index; 
                let isUnavailable = false; 
                if (forPlayer === 'cpu' && selectedP1Char && selectedP1Char.id === char.id) isUnavailable = true; 
                
                if (isUnavailable) { 
                    opt.classList.add('unavailable'); 
                    opt.disabled = true; 
                } else { 
                    if (index === currentIndex) opt.classList.add('selected'); 
                    opt.addEventListener('click', () => {
                        const charIndex = parseInt(opt.dataset.charIndex);
                        if (forPlayer === 'p1') {
                            currentP1CharIndex = charIndex;
                            confirmCharacter('p1');
                        } else if (forPlayer === 'cpu') {
                            if (selectedP1Char && availableCharacters[charIndex].id === selectedP1Char.id) {
                                return; 
                            }
                            currentCpuCharIndex = charIndex;
                            confirmCharacter('cpu');
                        }
                    });
                } 
                container.appendChild(opt); 
            });
        }

        function updateSelectedOption(container, newIndex, forPlayer) { 
            let actualNewIndex = newIndex; 
            if (forPlayer !== 'p1' && selectedP1Char) { 
                while(availableCharacters[actualNewIndex].id === selectedP1Char.id) { 
                    actualNewIndex = (actualNewIndex + 1) % availableCharacters.length; 
                    if (actualNewIndex === newIndex) break; 
                }
            } 
            if (forPlayer === 'p1') currentP1CharIndex = actualNewIndex; 
            else if (forPlayer === 'cpu') currentCpuCharIndex = actualNewIndex; 
            populateCharacterOptions(container, forPlayer, actualNewIndex);
        }

        function initializeSelections() { selectedP1Char = null; selectedCpuChar = null; selectedDifficulty = null; currentP1CharIndex = 0; currentCpuCharIndex = 0; populateCharacterOptions(p1CharOptionsContainer, 'p1', currentP1CharIndex); populateCharacterOptions(cpuCharOptionsContainer, 'cpu', currentCpuCharIndex); document.querySelectorAll('.difficulty-option').forEach(btn => btn.classList.remove('selected'));}
        
        const pvcpuModeButton = document.getElementById('pvcpuButton');
        if (pvcpuModeButton) {
            pvcpuModeButton.addEventListener('click', () => { 
                gameMode = 'pvcpu'; 
                initializeSelections(); 
                switchScreen('p1CharSelect'); 
            });
        }

        document.querySelectorAll('.difficulty-option').forEach(button => { button.addEventListener('click', () => { document.querySelectorAll('.difficulty-option').forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); selectedDifficulty = button.dataset.difficulty; startGame(); });});
        
        function confirmCharacter(playerType) { 
            if (playerType === 'p1') { selectedP1Char = { ...availableCharacters[currentP1CharIndex] }; updateSelectedOption(cpuCharOptionsContainer, currentCpuCharIndex, 'cpu'); switchScreen('cpuCharSelect'); }
            else if (playerType === 'cpu') { if (availableCharacters[currentCpuCharIndex].id !== selectedP1Char?.id) { selectedCpuChar = { ...availableCharacters[currentCpuCharIndex] }; switchScreen('difficultySelect'); }}
        }

        function initializePlayerObject(playerData) {
            return { ...playerData, x: 0, y: 0, width: PLAYER_WIDTH_SCALED, height: PLAYER_HEIGHT_SCALED, health: MAX_HEALTH, maxHealth: MAX_HEALTH, velocityX: 0, velocityY: 0, isJumping: false, isCrouching: false, isAttacking: false, attackType: null, attackTimer: 0, isDefending: false, facingRight: true, hitCounter: 0, consecutiveCrouchHitsTaken: 0, knockdownState: 'none', 
                groundedTimer: 0, comboSequence: [], lastAttackConnectTime: 0, actionCooldown: 0, 
                punchKeyHeldInternal: false, kickKeyHeldInternal: false, specialKeyAlreadyTriggered: false, 
                specialMeter: 0, specialReady: false, performingSpecial: null, 
                specialAnimTimer: 0, opponentSpecialMessageTimer: 0, 
                specialState: { bottlesDrunk: 0, bottlesThrown: 0, barTableX: -MAGAL_BAR_TABLE_WIDTH, barTableY: 0, barTableTargetX: 0, barTableVisible: false, punchesDelivered: 0 } 
            };
        }

        function startGame() { 
            if (!selectedP1Char || !selectedCpuChar || !selectedDifficulty) return; 
            setupCanvasDimensions(); 
            currentRound = 1; player1RoundWins = 0; player2RoundWins = 0;
            matchOver = false; isPaused = false; roundOverState = false;
            players[0] = initializePlayerObject(selectedP1Char); players[1] = initializePlayerObject(selectedCpuChar); 
            if(p1ControlsDisplayH3) p1ControlsDisplayH3.textContent = `J1: ${players[0].name.toUpperCase()}`; 
            if(p2ControlsDisplayDiv) {
                const p2H3 = p2ControlsDisplayDiv.querySelector('h3');
                if(p2H3) p2H3.textContent = `CPU: ${players[1].name.toUpperCase()}`;
                p2ControlsDisplayDiv.style.display = 'block';
            }
            switchScreen('game');
            startNewRound(); 
        }
        
        function startNewRound() {
            roundOverState = false; messageArea.textContent = ''; 
            projectiles = []; 
            roundStartMessageEl.textContent = `Round ${currentRound}`; roundStartMessageEl.style.display = 'block';
            resetRoundState(); updateScoreDisplay();
            setTimeout(() => {
                roundStartMessageEl.style.display = 'none';
                if (allImagesProcessedCheck && !matchOver) { 
                    if(!lastTime && !isPaused) { 
                         lastTime = performance.now() - 16.66; 
                         requestAnimationFrame(gameLoop);
                    }
                }
            }, 2000); 
        }

        function resetRoundState() { 
            players.forEach((player, index) => {
                if (player) {
                    player.health = player.maxHealth; player.facingRight = index === 0;
                    player.x = index === 0 ? canvasWidth * 0.25 - player.width / 2 : canvasWidth * 0.75 - player.width / 2; 
                    player.y = canvasHeight - player.height; 
                    player.velocityX = 0; player.velocityY = 0; player.isJumping = false; player.isCrouching = false;
                    player.isAttacking = false; player.isDefending = false; player.hitCounter = 0; player.consecutiveCrouchHitsTaken = 0;
                    player.knockdownState = 'none'; player.groundedTimer = 0;
                    player.comboSequence = []; player.lastAttackConnectTime = 0; player.actionCooldown = 0;
                    player.punchKeyHeldInternal = false; player.kickKeyHeldInternal = false; player.specialKeyAlreadyTriggered = false;
                    player.performingSpecial = null; player.specialAnimTimer = 0; player.opponentSpecialMessageTimer = 0;
                    player.specialState = { bottlesDrunk: 0, bottlesThrown: 0, barTableX: player.facingRight ? -MAGAL_BAR_TABLE_WIDTH - 50 : canvasWidth + 50, barTableY: canvasHeight - MAGAL_BAR_TABLE_HEIGHT - PLAYER_HEIGHT_SCALED + 80 , barTableTargetX: 0, barTableVisible: false, punchesDelivered: 0 };
                }
            });
            updateHealthBars(); updateSpecialBars(); 
        }
        
        document.addEventListener('keydown', (event) => { /* Keyboard gameplay input disabled */ });
        document.addEventListener('keyup', (event) => { /* Keyboard gameplay input disabled */ });
        
        function addTouchListener(element, keyName, isArrowDown = false) {
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // console.log(`${keyName} TOUCH START, keys.${keyName} will be true`); 
                keys[keyName] = true;
                if (isArrowDown && players[0] && 
                    !players[0].isJumping &&
                    players[0].knockdownState === 'none' &&
                    !players[0].performingSpecial) {
                    players[0].isCrouching = true;
                }
            }, { passive: false });
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                // console.log(`${keyName} TOUCH END, keys.${keyName} will be false`);
                keys[keyName] = false;
                if (isArrowDown && players[0]) {
                    players[0].isCrouching = false;
                }
            }, { passive: false });
        }

        addTouchListener(touchLeftBtn, 'arrowleft');
        addTouchListener(touchRightBtn, 'arrowright');
        addTouchListener(touchUpBtn, 'arrowup');
        addTouchListener(touchDownBtn, 'arrowdown', true);
        addTouchListener(touchPunchBtn, 'z');
        addTouchListener(touchKickBtn, 'x');
        addTouchListener(touchSpecialBtn, 'c');

        touchPauseBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentScreen === 'game' && !matchOver) {
                isPaused = !isPaused;
                pauseMessageEl.style.display = isPaused ? 'block' : 'none';
                if (!isPaused && !roundOverState) {
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
        }, { passive: false });


        restartButton.addEventListener('click', () => { gameOverModal.style.display = 'none'; matchOver = false; switchScreen('modeSelect'); });
        
        function handleRoundEnd(roundWinnerPlayer) {
            roundOverState = true; roundOverTimer = ROUND_END_DELAY;
            if (roundWinnerPlayer === players[0]) player1RoundWins++;
            else if (roundWinnerPlayer === players[1]) player2RoundWins++;
            updateScoreDisplay();
            messageArea.textContent = `${roundWinnerPlayer.name.toUpperCase()} VENCE O ROUND!`;
            const roundsToWin = Math.ceil(MAX_ROUNDS / 2);
            if (player1RoundWins >= roundsToWin || player2RoundWins >= roundsToWin) {
                matchOver = true;
                gameOverMessage.textContent = `${roundWinnerPlayer.name.toUpperCase()} VENCEU A PARTIDA!`;
                setTimeout(() => { if (matchOver) gameOverModal.style.display = 'flex'; }, 1000);
            }
        }

        function startScreenShake(intensity, duration) { screenShakeActive = true; currentScreenShakeIntensity = intensity; currentScreenShakeDuration = duration; }

        function handleControls() { 
            if (matchOver || currentScreen !== 'game' || isPaused || roundOverState) return;
            const p = players[0]; 
            
            if (!p) { 
                return;
            }

            if ((p.knockdownState !== 'none' && p.knockdownState !== 'special_hit_falling' && p.knockdownState !== 'special_hit_grounded') || p.performingSpecial) { 
                if(!p.performingSpecial && p.knockdownState !== 'special_hit_falling') p.velocityX = 0;
                return; 
            }
            if (p.actionCooldown > 0) return; 
            
            p.velocityX = 0;

            const canMoveHorizontally = !p.isAttacking && !(p.isCrouching && !p.isJumping);

            if (canMoveHorizontally) {
                if (keys['arrowleft']) {
                    p.velocityX = -PLAYER_SPEED_SCALED; 
                    p.facingRight = false;
                } else if (keys['arrowright']) {
                    p.velocityX = PLAYER_SPEED_SCALED; 
                    p.facingRight = true;
                }
            }
            
            if (keys['arrowup'] && !p.isJumping && !p.isCrouching) { 
                p.velocityY = JUMP_FORCE_SCALED; 0
                p.isJumping = true; 
                p.isCrouching = false; 
            }
            
            const wantsToPunch = keys['z']; 
            const wantsToKick = keys['x'];
            const wantsToSpecial = keys['c']; 

            p.isDefending = p.isCrouching && !wantsToPunch && !wantsToKick && !wantsToSpecial && !p.isAttacking && !p.isJumping;

            if (p.specialReady && wantsToSpecial && !p.specialKeyAlreadyTriggered && !p.isAttacking && !p.isCrouching && !p.isJumping) {
                p.specialKeyAlreadyTriggered = true; 
                p.specialReady = false; p.specialMeter = 0; updateSpecialBars();
                messageArea.textContent = `${p.name.toUpperCase()} ESPECIAL!`; setTimeout(() => messageArea.textContent = '', 1500);
                p.velocityX = 0; p.velocityY = 0; p.isAttacking = false; p.isCrouching = false; p.isJumping = false; 
                if (p.id === 'vini') { p.performingSpecial = 'vini_notification'; p.specialAnimTimer = VINI_SPECIAL_NOTIFICATION_DURATION; }
                else if (p.id === 'magal') { 
                    p.performingSpecial = 'magal_setup_bar'; p.specialAnimTimer = MAGAL_SPECIAL_SETUP_BAR_DURATION; 
                    p.specialState.bottlesDrunk = 0; p.specialState.bottlesThrown = 0;
                    p.specialState.barTableVisible = true;
                    const opponent = players[1]; 
                    if (opponent) p.facingRight = opponent.x > p.x; 
                    if (p.facingRight) { p.specialState.barTableX = p.x - MAGAL_BAR_TABLE_WIDTH - 10; p.specialState.barTableTargetX = p.x + p.width / 2 - MAGAL_BAR_TABLE_WIDTH / 2 + 30; } 
                    else { p.specialState.barTableX = p.x + p.width + 10; p.specialState.barTableTargetX = p.x + p.width / 2 - MAGAL_BAR_TABLE_WIDTH / 2 - 30; }
                } else if (p.id === 'pedro') {
                    p.performingSpecial = 'pedro_inject'; p.specialAnimTimer = PEDRO_SPECIAL_INJECT_DURATION; p.specialState.punchesDelivered = 0;
                }
                return; 
            }
            if (!wantsToSpecial && p.specialKeyAlreadyTriggered) {
                p.specialKeyAlreadyTriggered = false;
            }

            if (!p.isAttacking) { 
                let attackAction = null; 
                if (wantsToPunch && !p.punchKeyHeldInternal) { 
                    attackAction = 'punch'; 
                    p.punchKeyHeldInternal = true;
                } else if (!wantsToPunch && p.punchKeyHeldInternal) {
                    p.punchKeyHeldInternal = false;
                }

                if (wantsToKick && !p.kickKeyHeldInternal) { 
                    attackAction = 'kick'; 
                    p.kickKeyHeldInternal = true;
                } else if (!wantsToKick && p.kickKeyHeldInternal) {
                    p.kickKeyHeldInternal = false;
                }
                
                if (attackAction) {
                    p.isAttacking = true; p.isDefending = false;
                    if (p.isJumping) p.attackType = 'aerial_' + attackAction;
                    else if (p.isCrouching) p.attackType = 'crouch_' + attackAction;
                    else p.attackType = attackAction;
                    p.attackTimer = ATTACK_DURATION; performAttack(p, players[1]); 
                }
            }
        }
        
        function updateAI(cpu, target, difficulty, deltaTime) { 
            if (cpu.knockdownState !== 'none' || matchOver || cpu.actionCooldown > 0 || cpu.performingSpecial || isPaused || roundOverState) { cpu.velocityX = 0; return; }
            aiActionCooldown -= deltaTime; if (aiActionCooldown > 0) return;
            let baseCooldown = AI_ACTION_COOLDOWN_BASE; 
            if (difficulty === 'medium') baseCooldown -= 150; else if (difficulty === 'hard') baseCooldown -= 300;
            aiActionCooldown = Math.max(50, baseCooldown + (Math.random() * 100) - 50);
            const distanceX = target.x - cpu.x; const absDistanceX = Math.abs(distanceX);
            const canAttackRange = PLAYER_WIDTH_SCALED + ATTACK_RANGE_SCALED - 10; cpu.facingRight = distanceX > 0;
            let moveProb = 0.3, attackProb = 0.1, defendProb = 0.05, jumpProb = 0.05, crouchAttackProb = 0.05, specialProb = 0.0;
            if (difficulty === 'medium') { moveProb=0.5; attackProb=0.3; defendProb=0.2; jumpProb=0.1; crouchAttackProb = 0.1; specialProb = 0.1;}
            else if (difficulty === 'hard') { moveProb=0.7; attackProb=0.5; defendProb=0.4; jumpProb=0.15; crouchAttackProb = 0.2; specialProb = 0.25;}
            cpu.isDefending = false; cpu.isCrouching = false; 
            if (cpu.specialReady && Math.random() < specialProb && absDistanceX < canAttackRange * 2.5 && !cpu.isAttacking && !cpu.isCrouching && !cpu.isJumping) { 
                cpu.specialReady = false; cpu.specialMeter = 0; updateSpecialBars();
                messageArea.textContent = `${cpu.name.toUpperCase()} ESPECIAL!`; setTimeout(() => messageArea.textContent = '', 1500);
                cpu.velocityX = 0; cpu.velocityY = 0; cpu.isAttacking = false; cpu.isCrouching = false; cpu.isJumping = false;
                if (cpu.id === 'vini') { cpu.performingSpecial = 'vini_notification'; cpu.specialAnimTimer = VINI_SPECIAL_NOTIFICATION_DURATION; }
                else if (cpu.id === 'magal') { 
                    cpu.performingSpecial = 'magal_setup_bar'; cpu.specialAnimTimer = MAGAL_SPECIAL_SETUP_BAR_DURATION; 
                    cpu.specialState.bottlesDrunk = 0; cpu.specialState.bottlesThrown = 0;
                    cpu.specialState.barTableVisible = true;
                    if (cpu.facingRight) { cpu.specialState.barTableX = cpu.x - MAGAL_BAR_TABLE_WIDTH - 10; cpu.specialState.barTableTargetX = cpu.x + cpu.width / 2 - MAGAL_BAR_TABLE_WIDTH / 2 + 30; } 
                    else { cpu.specialState.barTableX = cpu.x + cpu.width + 10; cpu.specialState.barTableTargetX = cpu.x + cpu.width / 2 - MAGAL_BAR_TABLE_WIDTH / 2 - 30;}
                } else if (cpu.id === 'pedro') {
                    cpu.performingSpecial = 'pedro_inject'; cpu.specialAnimTimer = PEDRO_SPECIAL_INJECT_DURATION; cpu.specialState.punchesDelivered = 0;
                }
                return;
            }
            if (target.isAttacking && absDistanceX < canAttackRange + 30 && Math.random() < defendProb) { cpu.isCrouching = true; cpu.isDefending = true; setTimeout(() => { cpu.isDefending = false; cpu.isCrouching = false; }, 300); return; }
            if (absDistanceX < canAttackRange && Math.random() < attackProb && !cpu.isAttacking) {
                cpu.isAttacking = true;
                if (target.isJumping && Math.random() < 0.3 && difficulty !== 'easy') { cpu.attackType = 'punch'; }
                else if (Math.random() < crouchAttackProb && !cpu.isJumping && difficulty !== 'easy') { cpu.isCrouching = true; cpu.attackType = Math.random() < 0.5 ? 'crouch_punch' : 'crouch_kick';}
                else if (cpu.isJumping) { cpu.attackType = Math.random() < 0.5 ? 'aerial_punch' : 'aerial_kick'; }
                else { cpu.attackType = Math.random() < 0.5 ? 'punch' : 'kick'; }
                cpu.attackTimer = ATTACK_DURATION; performAttack(cpu, target);
                if (cpu.isCrouching && cpu.attackType.startsWith('crouch_')) { setTimeout(() => cpu.isCrouching = false, ATTACK_DURATION); }
                return; 
            }
            cpu.velocityX = 0;
            if (Math.random() < moveProb) { if (absDistanceX > canAttackRange * 1.2) { cpu.velocityX = cpu.facingRight ? PLAYER_SPEED_SCALED*0.7 : -PLAYER_SPEED_SCALED*0.7; } else if (absDistanceX < PLAYER_WIDTH_SCALED*0.8 && difficulty !== 'easy') { cpu.velocityX = cpu.facingRight ? -PLAYER_SPEED_SCALED*0.5 : PLAYER_SPEED_SCALED*0.5; } else { if (difficulty !== 'easy' && Math.random() < 0.3) { cpu.velocityX = (Math.random()<0.5?1:-1)*PLAYER_SPEED_SCALED*(Math.random()*0.4+0.2);}}}
            if (Math.random() < jumpProb && !cpu.isJumping && !cpu.isCrouching) { let jd = false; if (difficulty==='hard'&&target.isAttacking&&target.attackType?.startsWith('crouch')&&absDistanceX<canAttackRange){jd=true;}else if(difficulty!=='easy'&&Math.random()<0.3){jd=true;}else if(difficulty==='easy'&&Math.random()<0.1){jd=true;} if(jd){cpu.velocityY=JUMP_FORCE_SCALED;cpu.isJumping=true;}}
        }

        function updatePlayerState(player, deltaTime) {
            if (!player || isPaused || roundOverState) return; 
            if (player.actionCooldown > 0) { player.actionCooldown -= deltaTime; if (player.actionCooldown < 0) player.actionCooldown = 0;}
            
            const opponent = players.find(p => p !== player); 
            if (player.id === 'vini' && player.performingSpecial) {
                player.specialAnimTimer -= deltaTime;
                switch (player.performingSpecial) {
                    case 'vini_notification': if (player.specialAnimTimer <= 0) {player.performingSpecial = 'vini_hearts'; player.specialAnimTimer = VINI_SPECIAL_HEARTS_DURATION;} break;
                    case 'vini_hearts': if (player.specialAnimTimer <= 0) {player.performingSpecial = 'vini_message'; player.specialAnimTimer = VINI_SPECIAL_MESSAGE_DURATION;} break;
                    case 'vini_message': if (player.specialAnimTimer <= 0) {player.performingSpecial = 'vini_rage'; player.specialAnimTimer = VINI_SPECIAL_RAGE_TRANSFORM_DURATION; startScreenShake(SCREEN_SHAKE_INTENSITY, VINI_SPECIAL_RAGE_TRANSFORM_DURATION);} break;
                    case 'vini_rage': if (player.specialAnimTimer <= 0) {player.performingSpecial = 'vini_charge'; player.specialAnimTimer = VINI_SPECIAL_CHARGE_DURATION;} break;
                    case 'vini_charge': 
                        if (opponent) player.facingRight = opponent.x > player.x; 
                        if (player.specialAnimTimer <= 0) { player.performingSpecial = 'vini_rush'; player.velocityX = player.facingRight ? PLAYER_SPEED_SCALED * 4.5 : -PLAYER_SPEED_SCALED * 4.5; player.specialAnimTimer = VINI_SPECIAL_RUSH_DURATION; startScreenShake(SCREEN_SHAKE_INTENSITY + 8, VINI_SPECIAL_RUSH_DURATION); } 
                        break;
                    case 'vini_rush':
                        player.x += player.velocityX; 
                        if (opponent && Math.abs(player.x + player.width/2 - (opponent.x + opponent.width/2)) < (player.width/2 + opponent.width/2 - 5) && Math.abs(player.y + player.height/2 - (opponent.y + opponent.height/2)) < (player.height/2 + opponent.height/2 - 5) && !opponent.performingSpecial) { 
                            if (opponent.knockdownState !== 'special_hit_falling' && opponent.knockdownState !== 'special_hit_grounded') { 
                                opponent.health -= PUNCH_DAMAGE * SPECIAL_ATTACK_DAMAGE_MULTIPLIER; 
                                opponent.knockdownState = 'special_hit_falling'; 
                                opponent.velocityY = JUMP_FORCE_SCALED * KNOCKDOWN_JUMP_FORCE_MULTIPLIER * 1.5; 
                                opponent.velocityX = player.facingRight ? PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*2.5 : -PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*2.5; 
                                opponent.groundedTimer = OPPONENT_SPECIAL_HIT_FALL_DURATION; 
                                opponent.opponentSpecialMessageTimer = 4000; 
                                startScreenShake(SCREEN_SHAKE_INTENSITY + 10, 500); 
                                updateHealthBars(); 
                                if (opponent.health <= 0) { opponent.health = 0; handleRoundEnd(player); } 
                            }
                            player.performingSpecial = null; player.velocityX = 0; 
                        }
                        if (player.specialAnimTimer <= 0 || player.x < -player.width || player.x > canvasWidth) { player.performingSpecial = null; player.velocityX = 0;}
                        break;
                }
                return; 
            }
            
            if (player.id === 'magal' && player.performingSpecial) {
                player.specialAnimTimer -= deltaTime;
                switch (player.performingSpecial) {
                    case 'magal_setup_bar':
                        if (player.specialState.barTableX < player.specialState.barTableTargetX) { player.specialState.barTableX = Math.min(player.specialState.barTableTargetX, player.specialState.barTableX + MAGAL_BAR_SLIDE_SPEED); } 
                        else if (player.specialState.barTableX > player.specialState.barTableTargetX) { player.specialState.barTableX = Math.max(player.specialState.barTableTargetX, player.specialState.barTableX - MAGAL_BAR_SLIDE_SPEED); }
                        if (player.specialAnimTimer <= 0 && player.specialState.barTableX === player.specialState.barTableTargetX) { 
                            player.specialState.bottlesDrunk = 0;
                            player.specialState.bottlesThrown = 0; 
                            player.performingSpecial = 'magal_drinking_bottle'; 
                            player.specialAnimTimer = MAGAL_SPECIAL_DRINK_DURATION_PER_BOTTLE; 
                        }
                        break;
                    case 'magal_drinking_bottle':
                        if (player.specialAnimTimer <= 0) {
                            player.specialState.bottlesDrunk++;
                            player.performingSpecial = 'magal_throwing_bottle'; 
                            player.specialAnimTimer = MAGAL_SPECIAL_THROW_INTERVAL; 
                        }
                        break;
                    case 'magal_throwing_bottle':
                        if (player.specialAnimTimer <= 0) {
                            if (opponent) player.facingRight = opponent.x > player.x; 
                            projectiles.push({ x: player.facingRight ? player.x + player.width : player.x - MAGAL_SPECIAL_BOTTLE_WIDTH, y: player.y + player.height / 3, width: MAGAL_SPECIAL_BOTTLE_WIDTH, height: MAGAL_SPECIAL_BOTTLE_HEIGHT, velocityX: player.facingRight ? MAGAL_SPECIAL_BOTTLE_SPEED : -MAGAL_SPECIAL_BOTTLE_SPEED, ownerId: player.id, type: 'magal_bottle', isActive: true, color: 'SaddleBrown'});
                            player.specialState.bottlesThrown++;
                            if (player.specialState.bottlesThrown < 5) { 
                                player.performingSpecial = 'magal_drinking_bottle'; 
                                player.specialAnimTimer = MAGAL_SPECIAL_DRINK_DURATION_PER_BOTTLE;
                            } else { 
                                player.performingSpecial = 'magal_disco_dance';
                                player.specialAnimTimer = MAGAL_SPECIAL_DISCO_DURATION;
                            }
                        }
                        break;
                    case 'magal_disco_dance': if (player.specialAnimTimer <= 0) { player.performingSpecial = 'magal_final_message'; player.specialAnimTimer = MAGAL_SPECIAL_FINAL_MESSAGE_DURATION; } break;
                    case 'magal_final_message': if (player.specialAnimTimer <= 0) { player.performingSpecial = null; player.specialState.barTableVisible = false; } break;
                }
                return; 
            }

            if (player.id === 'pedro' && player.performingSpecial) {
                player.specialAnimTimer -= deltaTime;
                switch(player.performingSpecial) {
                    case 'pedro_inject':
                        if (player.specialAnimTimer <= 0) { player.performingSpecial = 'pedro_pump'; player.specialAnimTimer = PEDRO_SPECIAL_PUMP_DURATION; }
                        break;
                    case 'pedro_pump':
                        if (opponent) player.facingRight = opponent.x > player.x; 
                        if (player.specialAnimTimer <= 0) { 
                            player.performingSpecial = 'pedro_rush'; 
                            player.velocityX = player.facingRight ? PLAYER_SPEED_SCALED * PEDRO_SPECIAL_RUSH_SPEED_MULTIPLIER : -PLAYER_SPEED_SCALED * PEDRO_SPECIAL_RUSH_SPEED_MULTIPLIER;
                            player.specialAnimTimer = VINI_SPECIAL_RUSH_DURATION; 
                            startScreenShake(SCREEN_SHAKE_INTENSITY + 4, VINI_SPECIAL_RUSH_DURATION);
                        }
                        break;
                    case 'pedro_rush':
                        player.x += player.velocityX;
                        if (opponent && Math.abs(player.x + player.width/2 - (opponent.x + opponent.width/2)) < (player.width/2 + opponent.width/2 - 5) && Math.abs(player.y + player.height/2 - (opponent.y + opponent.height/2)) < (player.height/2 + opponent.height/2 - 5) && !opponent.performingSpecial) {
                            player.performingSpecial = 'pedro_punch_combo';
                            player.specialState.punchesDelivered = 0;
                            player.specialAnimTimer = PEDRO_SPECIAL_PUNCH_INTERVAL;
                            player.velocityX = 0; 
                        }
                        if (player.specialAnimTimer <= 0 || player.x < -player.width || player.x > canvasWidth) { player.performingSpecial = null; player.velocityX = 0;}
                        break;
                    case 'pedro_punch_combo':
                        if (player.specialAnimTimer <= 0) {
                            if (player.specialState.punchesDelivered < PEDRO_SPECIAL_PUNCH_COUNT && opponent && !opponent.performingSpecial && opponent.knockdownState === 'none') {
                                opponent.health -= PUNCH_DAMAGE * 1.2; 
                                startScreenShake(SCREEN_SHAKE_INTENSITY, 150); 
                                player.specialState.punchesDelivered++;
                                if (player.specialState.punchesDelivered >= PEDRO_SPECIAL_PUNCH_COUNT) { 
                                    opponent.knockdownState = 'special_hit_falling'; 
                                    opponent.velocityY = JUMP_FORCE_SCALED * KNOCKDOWN_JUMP_FORCE_MULTIPLIER * PEDRO_SPECIAL_FINAL_PUNCH_LAUNCH_MULTIPLIER; 
                                    opponent.velocityX = player.facingRight ? PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*1.5 : -PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*1.5; 
                                    opponent.groundedTimer = OPPONENT_SPECIAL_HIT_FALL_DURATION; 
                                    startScreenShake(SCREEN_SHAKE_INTENSITY + 6, 500); 
                                    player.performingSpecial = null;
                                } else {
                                    player.specialAnimTimer = PEDRO_SPECIAL_PUNCH_INTERVAL; 
                                }
                                updateHealthBars();
                                if (opponent.health <= 0) { opponent.health = 0; handleRoundEnd(player); player.performingSpecial = null; }
                            } else {
                                player.performingSpecial = null; 
                            }
                        }
                        break;
                }
                return;
            }


            if (player.knockdownState === 'special_hit_falling') {
                 player.velocityY += GRAVITY * 0.3; player.y += player.velocityY; player.x += player.velocityX;
                 if (player.x <= 0 || player.x + player.width >= canvasWidth) { player.velocityX *= -0.7; player.x = Math.max(0, Math.min(player.x, canvasWidth - player.width)); startScreenShake(SCREEN_SHAKE_INTENSITY + 5, 300); }
                 if (player.y + player.height >= canvasHeight) { player.y = canvasHeight - player.height; player.velocityY = 0; player.velocityX = 0; player.knockdownState = 'special_hit_grounded'; }
                  return; 
            } else if (player.knockdownState === 'special_hit_grounded') {
                 player.opponentSpecialMessageTimer -= deltaTime;
                 if(player.opponentSpecialMessageTimer <= 0) { player.knockdownState = 'none'; }
                 return;
            }
            if (player.knockdownState === 'falling') { player.velocityY += GRAVITY; player.y += player.velocityY; player.x += player.velocityX; if (player.y + player.height >= canvasHeight) { player.y = canvasHeight - player.height; player.velocityY = 0; player.velocityX = 0; player.knockdownState = 'grounded'; player.groundedTimer = GROUNDED_DURATION; startScreenShake(SCREEN_SHAKE_INTENSITY, SCREEN_SHAKE_DURATION_MS);}}
            else if (player.knockdownState === 'grounded') { player.groundedTimer -= deltaTime; if (player.groundedTimer <= 0) player.knockdownState = 'none';}
            else { 
                if (player.isAttacking) { player.attackTimer -= deltaTime; if (player.attackTimer <= 0) { player.isAttacking = false; player.attackType = null; }}
                if (!(player.isCrouching && !player.isJumping) || player.isAttacking) {
                     player.x += player.velocityX;
                } else {
                     player.velocityX = 0; 
                }
                player.velocityY += GRAVITY;
                player.y += player.velocityY;
                if (player.y + player.height > canvasHeight) { player.y = canvasHeight - player.height; player.velocityY = 0; if(player.isJumping) player.isJumping = false; }
            }
            if (player.x < 0) { player.x = 0; if (player.knockdownState === 'falling') player.velocityX = 0; }
            if (player.x + player.width > canvasWidth) { player.x = canvasWidth - player.width; if (player.knockdownState === 'falling') player.velocityX = 0; }
        }
        
        function checkCombo(attacker) { let longestMatch = null; for (const combo of combos) { if (attacker.comboSequence.length >= combo.sequence.length) { const sequenceToCheck = attacker.comboSequence.slice(-combo.sequence.length); if (sequenceToCheck.every((val, index) => val === combo.sequence[index])) { longestMatch = combo; }}} return longestMatch;}

        function performAttack(attacker, target) {
            if (!attacker || !target || !attacker.isAttacking || matchOver || 
                (target.knockdownState !== 'none' && target.knockdownState !== 'special_hit_falling' && target.knockdownState !== 'special_hit_grounded') || 
                attacker.actionCooldown > 0 || attacker.performingSpecial || target.performingSpecial) return;

            let hit = false; let attackHitboxYOffset = attacker.height / 4; let attackHitboxHeight = attacker.height / 2;
            if (attacker.attackType.startsWith('crouch_')) { attackHitboxYOffset = attacker.height * 0.6; attackHitboxHeight = attacker.height * 0.4; }
            else if (attacker.attackType.startsWith('aerial_')) { attackHitboxYOffset = attacker.height / 3; }
            const attackHitbox = { x: attacker.facingRight ? attacker.x + attacker.width : attacker.x - ATTACK_RANGE_SCALED, y: attacker.y + attackHitboxYOffset, width: ATTACK_RANGE_SCALED, height: attackHitboxHeight };
            if (attackHitbox.x < target.x + target.width && attackHitbox.x + attackHitbox.width > target.x && attackHitbox.y < target.y + target.height && attackHitbox.y + attackHitbox.height > target.y) {
                if (target.isDefending && !attacker.attackType.includes('special')) { attacker.comboSequence = []; attacker.lastAttackConnectTime = 0; return; }
                hit = true;
                if (target.specialMeter < SPECIAL_METER_MAX) { target.specialMeter++; if (target.specialMeter >= SPECIAL_METER_MAX) { target.specialReady = true; messageArea.textContent = `${target.name.toUpperCase()} ESPECIAL PRONTO!`; setTimeout(() => messageArea.textContent = '', 1500); } updateSpecialBars(); }
                if (!attacker.attackType.startsWith('crouch_')) target.consecutiveCrouchHitsTaken = 0;
                const currentTime = Date.now();
                if (attacker.comboSequence.length > 0 && (currentTime - attacker.lastAttackConnectTime > COMBO_WINDOW_MS)) { attacker.comboSequence = []; }
                let comboRelevantAttackType = attacker.attackType; if(attacker.attackType.includes('_')) comboRelevantAttackType = attacker.attackType.split('_')[1];
                attacker.comboSequence.push(comboRelevantAttackType); attacker.lastAttackConnectTime = currentTime;
                const performedCombo = checkCombo(attacker);
                if (performedCombo) { messageArea.textContent = `${attacker.name.toUpperCase()}: ${performedCombo.name}!`; setTimeout(() => messageArea.textContent = '', 1500); attacker.actionCooldown = POST_COMBO_COOLDOWN_MS; attacker.comboSequence = []; }
                let damage = (attacker.attackType.includes('punch')) ? PUNCH_DAMAGE : KICK_DAMAGE; target.health -= damage; 
                if (attacker.attackType.startsWith('aerial_')) { target.velocityX = attacker.facingRight ? AERIAL_ATTACK_PUSHBACK_FORCE : -AERIAL_ATTACK_PUSHBACK_FORCE; setTimeout(() => { if(Math.abs(target.velocityX) === AERIAL_ATTACK_PUSHBACK_FORCE) target.velocityX = 0; }, 300); target.hitCounter = 0; target.consecutiveCrouchHitsTaken = 0;}
                else if (attacker.attackType.startsWith('crouch_')) { target.consecutiveCrouchHitsTaken++; target.hitCounter = 0; if (target.consecutiveCrouchHitsTaken >= CROUCH_KNOCKDOWN_THRESHOLD) { target.knockdownState = 'falling'; target.velocityY = JUMP_FORCE_SCALED*KNOCKDOWN_JUMP_FORCE_MULTIPLIER*0.8; target.velocityX = attacker.facingRight ? PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*0.5 : -PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER*0.5; target.consecutiveCrouchHitsTaken = 0; target.isAttacking=false; target.isDefending=false; target.isJumping=true;}}
                else { target.hitCounter++; if (target.hitCounter >= KNOCKDOWN_HIT_THRESHOLD && target.knockdownState === 'none') { target.knockdownState = 'falling'; target.velocityY = JUMP_FORCE_SCALED*KNOCKDOWN_JUMP_FORCE_MULTIPLIER; target.velocityX = attacker.facingRight ? PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER : -PLAYER_SPEED_SCALED*KNOCKDOWN_PUSHBACK_SPEED_MULTIPLIER; target.hitCounter=0; target.isAttacking=false; target.isDefending=false; target.isJumping=true;}}
                updateHealthBars(); 
                if (target.health <= 0) { target.health = 0; handleRoundEnd(attacker); } 
            } else { attacker.comboSequence = []; attacker.lastAttackConnectTime = 0; }
        }
        
        function drawTextBox(x, y, text, maxWidth, lineHeight, backgroundColor = 'rgba(0, 0, 0, 0.7)', textColor = 'white', borderColor = 'white', fontSize = 10) { 
            ctx.font = `${fontSize}px 'Courier New', Courier, monospace`; 
            const words = text.split(' '); let line = ''; const lines = [];
            for (let n = 0; n < words.length; n++) { const testLine = line + words[n] + ' '; const metrics = ctx.measureText(testLine); const testWidth = metrics.width; if (testWidth > maxWidth && n > 0) { lines.push(line); line = words[n] + ' '; } else { line = testLine; }}
            lines.push(line);
            const boxPadding = 5;
            const boxHeight = lines.length * lineHeight + boxPadding * 2; 
            const textBlockWidth = Math.min(maxWidth, ctx.measureText(lines.reduce((a,b) => a.length > b.length ? a : b, '')).width); 
            const boxWidth = textBlockWidth + boxPadding * 2;

            const boxX = x - boxWidth / 2; 
            const boxY = y - boxHeight - 10; 
            ctx.fillStyle = backgroundColor; ctx.strokeStyle = borderColor; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.rect(boxX, boxY, boxWidth, boxHeight); ctx.fill(); ctx.stroke();
            ctx.fillStyle = textColor; ctx.textAlign = 'center';
            for (let i = 0; i < lines.length; i++) { ctx.fillText(lines[i].trim(), x, boxY + boxPadding + (i * lineHeight) + lineHeight/2 + 2); } 
            ctx.textAlign = 'left'; 
        }

        function drawProjectiles() {
            projectiles.forEach(proj => {
                if (proj.isActive) {
                    ctx.fillStyle = proj.color || 'SaddleBrown'; 
                    ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
                }
            });
        }

        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                if (!proj.isActive) continue;
                proj.x += proj.velocityX;
                const opponent = players.find(p => p.id !== proj.ownerId);
                if (opponent && !opponent.performingSpecial && opponent.knockdownState === 'none') { 
                     if (proj.x < opponent.x + opponent.width && proj.x + proj.width > opponent.x && proj.y < opponent.y + opponent.height && proj.y + proj.height > opponent.y) {
                        opponent.health -= MAGAL_SPECIAL_BOTTLE_DAMAGE;
                        opponent.hitCounter++; 
                        if (opponent.health <= 0) { opponent.health = 0; handleRoundEnd(players.find(p=>p.id === proj.ownerId)); }
                        updateHealthBars();
                        proj.isActive = false; 
                    }
                }
                if (proj.x > canvasWidth || proj.x < -proj.width) { proj.isActive = false; }
            }
            projectiles = projectiles.filter(proj => proj.isActive); 
        }


        function drawPlayer(player) {
            if (!player) return;
            let playerDrawHeight = player.height; 
            let playerDrawY = player.y;
            let currentFillStyle = player.color; 

            if (player.isCrouching && !player.isJumping && !player.performingSpecial) { 
                playerDrawHeight = player.height * 0.7; 
                playerDrawY = player.y + player.height * 0.3; 
            }

            const spriteToDraw = playerSprites[player.spriteKey]; 

            if (player.id === 'vini' && player.performingSpecial) {
                switch (player.performingSpecial) {
                    case 'vini_notification': ctx.fillStyle = 'yellow'; ctx.fillRect(player.x + player.width / 2 - 5, player.y - 20, 10, 10); break;
                    case 'vini_hearts': ctx.fillStyle = 'pink'; for(let i=0; i<3; i++) { ctx.beginPath(); ctx.moveTo(player.x + player.width/2 + (i*15-15) , player.y - 20 - (i%2 * 5)); ctx.bezierCurveTo(player.x + player.width/2 + (i*15-15) +5, player.y - 30 - (i%2 * 5), player.x + player.width/2 + (i*15-15) +10, player.y -15 - (i%2 * 5), player.x + player.width/2 + (i*15-15), player.y -10- (i%2 * 5) ); ctx.bezierCurveTo(player.x + player.width/2 + (i*15-15) -10, player.y -15- (i%2 * 5), player.x + player.width/2 + (i*15-15) -5, player.y -30- (i%2 * 5), player.x + player.width/2 + (i*15-15), player.y -20- (i%2 * 5)); ctx.fill(); } break;
                    case 'vini_message': drawTextBox(player.x + player.width/2, player.y, "namorada: a gente tem que terminar, eu gosto de outro", 120, 12); break; 
                    case 'vini_rage': case 'vini_charge': case 'vini_rush':
                        currentFillStyle = '#cc0000'; 
                        ctx.fillStyle = '#ddcc00'; 
                        const hornWidth = 10; const hornHeight = 20; 
                        const headX = player.x + player.width/2; 
                        const headY = playerDrawY - 3; 
                        ctx.beginPath(); ctx.moveTo(headX - player.width/4, headY); ctx.lineTo(headX - player.width/4 - hornWidth/2, headY - hornHeight); ctx.lineTo(headX - player.width/4 + hornWidth/2, headY - hornHeight); ctx.closePath(); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(headX + player.width/4, headY); ctx.lineTo(headX + player.width/4 - hornWidth/2, headY - hornHeight); ctx.lineTo(headX + player.width/4 + hornWidth/2, headY - hornHeight); ctx.closePath(); ctx.fill();
                        if(player.performingSpecial === 'vini_rage') startScreenShake(SCREEN_SHAKE_INTENSITY + 2, 100); 
                        break;
                }
            }
            if (player.id === 'magal' && player.performingSpecial) {
                if (player.specialState.barTableVisible) { 
                    ctx.fillStyle = '#543414'; 
                    ctx.fillRect(player.specialState.barTableX, player.specialState.barTableY, MAGAL_BAR_TABLE_WIDTH, MAGAL_BAR_TABLE_HEIGHT);
                    ctx.fillStyle = '#888888'; 
                    ctx.fillRect(player.specialState.barTableX + MAGAL_BAR_TABLE_WIDTH / 2 - 10, player.specialState.barTableY - 20, 20, 20); 
                }
                switch (player.performingSpecial) {
                    case 'magal_drinking_bottle': 
                        ctx.fillStyle = 'green';
                        const drinkCycle = Math.floor((MAGAL_SPECIAL_DRINK_DURATION_PER_BOTTLE - player.specialAnimTimer) / (MAGAL_SPECIAL_DRINK_DURATION_PER_BOTTLE / 2));
                        if (drinkCycle % 2 === 0) { ctx.fillRect(player.facingRight ? player.x + player.width - 3 : player.x - 3 , player.y + player.height/2 - 7, 6, 14); } 
                        break;
                    case 'magal_disco_dance':
                        const danceColorIndex = Math.floor(Date.now() / 150) % 4; 
                        const danceColors = [player.color, 'lime', 'fuchsia', 'aqua'];
                        currentFillStyle = danceColors[danceColorIndex];
                        break;
                    case 'magal_final_message': drawTextBox(player.x + player.width/2, player.y, "nunca mais eu vou beber, EU JURO!", 180, 12); break; 
                }
            }
            if (player.id === 'pedro' && player.performingSpecial) {
                switch(player.performingSpecial) {
                    case 'pedro_inject':
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; 
                        ctx.fillRect(player.x, playerDrawY, player.width, playerDrawHeight);
                        ctx.fillStyle = 'grey'; ctx.fillRect(player.x + player.width/2 - 1, playerDrawY + playerDrawHeight/2 - 10, 2, 7); 
                        ctx.fillStyle = 'silver'; ctx.fillRect(player.x + player.width/2 - 0.5, playerDrawY + playerDrawHeight/2 - 13, 1, 3);
                        break;
                    case 'pedro_pump':
                        currentFillStyle = '#004d00'; 
                        ctx.fillStyle = 'silver';
                        ctx.fillRect(player.x - 7, playerDrawY + playerDrawHeight/3 - 3, player.width + 14, 6); 
                        const pumpCycle = Math.sin( (PEDRO_SPECIAL_PUMP_DURATION - player.specialAnimTimer) / (PEDRO_SPECIAL_PUMP_DURATION / (Math.PI * 4)) ); 
                        playerDrawY += pumpCycle * 3; 
                        break;
                    case 'pedro_rush':
                    case 'pedro_punch_combo':
                        currentFillStyle = '#006400'; 
                        break;
                }
            }


            if (player.knockdownState === 'special_hit_grounded' && player.opponentSpecialMessageTimer > 0) { drawTextBox(player.x + player.width/2, player.y, "se acalma disgraça, quem mandou ser corno", 180, 12, 'rgba(50,50,50,0.8)', '#ffdddd');}
            
            if (player.knockdownState === 'grounded' || player.knockdownState === 'special_hit_grounded') {
                currentFillStyle = '#718096'; 
            } else if (player.isDefending && player.knockdownState === 'none' && !player.performingSpecial) { 
                ctx.fillStyle = 'rgba(160, 174, 192, 0.7)'; 
                ctx.fillRect(player.x - 3, playerDrawY - 3, player.width + 6, playerDrawHeight + 6); 
            }

            if (spriteToDraw && spriteToDraw.complete && spriteToDraw.naturalHeight !== 0 && !(player.id === 'pedro' && (player.performingSpecial === 'pedro_pump' || player.performingSpecial === 'pedro_rush' || player.performingSpecial === 'pedro_punch_combo'))) { 
                ctx.save();
                if (!player.facingRight) {
                    ctx.translate(player.x + player.width, playerDrawY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(spriteToDraw, 0, 0, player.width, playerDrawHeight);
                } else {
                    ctx.drawImage(spriteToDraw, player.x, playerDrawY, player.width, playerDrawHeight);
                }
                ctx.restore();
            } else { 
                ctx.fillStyle = currentFillStyle; 
                ctx.fillRect(player.x, playerDrawY, player.width, playerDrawHeight);
            }

            if (player.isAttacking && player.knockdownState === 'none' && !player.performingSpecial) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
                let attackHitboxYOffset = playerDrawHeight/4; let attackHitboxHeight = playerDrawHeight/2;
                if (player.attackType.startsWith('crouch_')) { attackHitboxYOffset = playerDrawHeight*0.5; attackHitboxHeight = playerDrawHeight*0.4;}
                else if (player.attackType.startsWith('aerial_')) { attackHitboxYOffset = playerDrawHeight/3; }
                const attackVisual = { x: player.facingRight ? player.x+player.width : player.x-ATTACK_RANGE_SCALED, y: playerDrawY+attackHitboxYOffset, width: ATTACK_RANGE_SCALED, height: attackHitboxHeight };
                ctx.fillRect(attackVisual.x, attackVisual.y, attackVisual.width, attackVisual.height);
            }
        }
        
        function gameLoop(timestamp) {
            if (currentScreen !== 'game' || matchOver) { 
                return;
            }
            if (isPaused) { requestAnimationFrame(gameLoop); return; } 

            const deltaTime = (timestamp - lastTime) || 16.66; lastTime = timestamp;
            
            if (roundOverState) {
                roundOverTimer -= deltaTime;
                if (roundOverTimer <= 0) {
                    currentRound++;
                    if (currentRound > MAX_ROUNDS || player1RoundWins >= Math.ceil(MAX_ROUNDS/2) || player2RoundWins >= Math.ceil(MAX_ROUNDS/2) ) {
                        // Match over logic handled by handleRoundEnd
                    } else {
                        startNewRound();
                    }
                }
            } else { 
                players.forEach(p => { if (p && p.actionCooldown > 0) { p.actionCooldown -= deltaTime; if (p.actionCooldown < 0) p.actionCooldown = 0;}});
                let dx = 0, dy = 0;
                if (screenShakeActive) { currentScreenShakeDuration -= deltaTime; if (currentScreenShakeDuration <= 0) screenShakeActive = false; else { dx = (Math.random()-0.5)*2*currentScreenShakeIntensity; dy = (Math.random()-0.5)*2*currentScreenShakeIntensity; }}
                ctx.save(); ctx.translate(dx, dy);
                ctx.clearRect(-currentScreenShakeIntensity, -currentScreenShakeIntensity, canvasWidth+currentScreenShakeIntensity*2, canvasHeight+currentScreenShakeIntensity*2);
                
                updateProjectiles(deltaTime); 
                handleControls(); 
                if (gameMode === 'pvcpu' && players[1] && !matchOver) { updateAI(players[1], players[0], selectedDifficulty, deltaTime); }
                players.forEach(player => { updatePlayerState(player, deltaTime); }); 
                
                drawProjectiles(); 
                players.forEach(player => { drawPlayer(player); });
                
                ctx.restore();
            }
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = () => {
            setupCanvasDimensions(); 
            window.addEventListener('resize', setupCanvasDimensions); 
            switchScreen('modeSelect');
        };

    </script>
</body>
</html>